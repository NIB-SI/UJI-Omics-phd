---
title: "01_DE"
author: "Maria, MPE, zagor"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_caption: yes
    self_contained: yes
    fig_width: 12
    fig_height: 9
    toc: yes
    toc_depth: 2
    toc_float: true
    number_sections: yes
    theme: flatly
    highlight: tango
  pdf_document:
    toc: yes
    toc_depth: '2'
  word_document:
    toc: yes
    toc_depth: '2'
editor_options:
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(#dev = c('pdf', 'png'),  # this embeds pdf and crates scrolable blocks
                      dev = c('png'), 
                      fig.align = 'center', 
                      fig.height = 9, 
                      fig.width = 12 ,
                      warning = FALSE, message = FALSE
                      )
# options(knitr.table.format = "html")

```


# Libraries

```{r,  echo=FALSE, warning=FALSE, message=FALSE}

rm(list = ls(all = TRUE))
gc()

set.seed(123456)


`%nin%` = Negate(`%in%`)

library(RColorBrewer)
library(raster)

# library(ComplexHeatmap)
# library(circlize)

library(ggplot2)

library(magrittr)

# devtools::install_github("gaospecial/ggVennDiagram")


```


# Functions

## MDS

<https://www.gastonsanchez.com/visually-enforced/how-to/2013/01/23/MDS-in-R/>


```{r, echo=FALSE, message=FALSE, warning=FALSE}

my.NMDS <- function(mymat, stress.levels, time.levels, title, my.ggplot.palette){

    

    nmds = vegan::metaMDS(t(mymat), 
                          distance = "euclidean",
                          k = 3, try = 20, trymax = 100,
                          trace = FALSE)
    
    data.scores = as.data.frame(vegan::scores(nmds)$sites)
    data.scores$Treatment = stress.levels
    data.scores$SamplingDay = time.levels
    data.scores$PlantNo = PlantNo
    
    g12 = ggplot(data.scores, aes(x = NMDS1, y = NMDS2)) +
      geom_point(size = 3, aes( shape = PlantNo, colour = Treatment)) +
      theme(axis.text.y = element_text(colour = "black", size = 10, face = "bold"),
            axis.text.x = element_text(colour = "black", face = "bold", size = 10),
            legend.text = element_text(size = 6, 
                                       #face ="bold", 
                                       colour ="black"
            ),
            legend.position = "none", axis.title.y = element_text(face = "bold", size = 14),
            axis.title.x = element_text(face = "bold", size = 14, colour = "black"),
            legend.title = element_text(size = 8, 
                                        colour = "black"#, 
                                        #face = "bold"
            ),
            panel.background = element_blank(), panel.border = element_rect(colour = "black", 
                                                                            fill = NA, 
                                                                            size = 1.2),
            legend.key=element_blank()) +
      labs(x = "MDS1", colour = "Condition", y = "MDS2", shape = "Replicate") + 
      ggtitle(title) +
      scale_color_manual(values = my.ggplot.palette)
    
    g13 = ggplot(data.scores, aes(x = NMDS1, y = NMDS3)) +
      geom_point(size = 3, aes( shape = PlantNo, colour = Treatment)) +
      theme(axis.text.y = element_text(colour = "black", size = 10, face = "bold"),
            axis.text.x = element_text(colour = "black", face = "bold", size = 10),
            legend.text = element_text(size = 6, 
                                       #face ="bold", 
                                       colour ="black"
                                       ),
            legend.position = "none", axis.title.y = element_text(face = "bold", size = 14),
            axis.title.x = element_text(face = "bold", size = 14, colour = "black"),
            legend.title = element_text(size = 8, 
                                        colour = "black"#, 
                                        #face = "bold"
                                        ),
            panel.background = element_blank(), panel.border = element_rect(colour = "black", 
                                                                            fill = NA, 
                                                                            size = 1.2),
            legend.key=element_blank()) +
      labs(x = "MDS1", colour = "Condition", y = "MDS3", shape = "Replicate") + 
      ggtitle(title) +
      scale_color_manual(values = my.ggplot.palette)
    
    g23 = ggplot(data.scores, aes(x = NMDS2, y = NMDS3)) +
      geom_point(size = 3, aes( shape = PlantNo, colour = Treatment)) +
      theme(axis.text.y = element_text(colour = "black", size = 10, face = "bold"),
            axis.text.x = element_text(colour = "black", face = "bold", size = 10),
            legend.text = element_text(size = 6, 
                                       #face ="bold", 
                                       colour ="black"
            ),
            legend.position = "right", axis.title.y = element_text(face = "bold", size = 14),
            axis.title.x = element_text(face = "bold", size = 14, colour = "black"),
            legend.title = element_text(size = 8, 
                                        colour = "black"#, 
                                        #face = "bold"
            ),
            panel.background = element_blank(), panel.border = element_rect(colour = "black", 
                                                                            fill = NA, 
                                                                            size = 1.2),
            legend.key=element_blank()) +
      labs(x = "MDS2", colour = "Condition", y = "MDS3", shape = "Replicate") + 
      ggtitle(title) +
      scale_color_manual(values = my.ggplot.palette)
    
    
    ds = data.scores
    ds$trt = ds$Treatment # paste(ds$Treatment, ds$SamplingDay, sep = '_')
    cent <- aggregate(cbind(NMDS1, NMDS2) ~ trt, data = ds, FUN = mean)
    cent$time = factor(as.numeric(gsub('h', '', gsub('.*_', '', cent$trt))), levels = levels(time.levels))
    cent$stress = factor(gsub('_.*', '', cent$trt), levels = unique(gsub('_.*', '', cent$trt)))
    segs <- merge(ds, setNames(cent, c('trt','oNMDS1','oNMDS2')),
                  by = 'trt', sort = FALSE)
    ds$time = factor(as.numeric(gsub('h', '', gsub('.*_', '', ds$trt))), levels = levels(time.levels))
    ds$stress = factor(gsub('_.*', '', ds$trt), levels = unique(gsub('_.*', '', ds$trt)))
    
    gc12 = ggplot(ds, aes(x = NMDS1, y = NMDS2, colour = ds$trt)) +
      geom_segment(data = segs,
                   mapping = aes(xend = oNMDS1, yend = oNMDS2)) + 
      geom_point(data = cent, 
                 size = 3, 
                 aes(colour = trt,
                 shape = time)) +
      geom_point(size = 1) +
      coord_fixed()     + 
      scale_color_manual(name = "Condition", values = my.ggplot.palette) +
      ggtitle('Centroids') + 
      scale_shape_manual(name = "Hours",
                         breaks = levels(time.levels) ,
                         values =  c(1, 16) #, 0, 15, 2, 17, 8)
                         ) +
      theme(axis.text.y = element_text(colour = "black", size = 10, face = "bold"),
            axis.text.x = element_text(colour = "black", face = "bold", size = 10),
            legend.text = element_text(size = 6, 
                                       #face ="bold", 
                                       colour ="black"
            ),
            legend.position = "none", axis.title.y = element_text(face = "bold", size = 14),
            axis.title.x = element_text(face = "bold", size = 14, colour = "black"),
            legend.title = element_text(size = 8, 
                                        colour = "black"#, 
                                        #face = "bold"
            ),
            panel.background = element_blank(), panel.border = element_rect(colour = "black", 
                                                                            fill = NA, 
                                                                            size = 1.2),
            legend.key=element_blank())

    
    ds = data.scores
    ds$trt = ds$Treatment # paste(ds$Treatment, ds$SamplingDay, sep = '_')
    cent <- aggregate(cbind(NMDS1, NMDS3) ~ trt, data = ds, FUN = mean)
    cent$time = factor(as.numeric(gsub('h', '', gsub('.*_', '', cent$trt))), levels = levels(time.levels))
    cent$stress = factor(gsub('_.*', '', cent$trt), levels = unique(gsub('_.*', '', cent$trt)))
    segs <- merge(ds, setNames(cent, c('trt','oNMDS1','oNMDS3')),
                  by = 'trt', sort = FALSE)
    ds$time = factor(as.numeric(gsub('h', '', gsub('.*_', '', ds$trt))), levels = levels(time.levels))
    ds$stress = factor(gsub('_.*', '', ds$trt), levels = unique(gsub('_.*', '', ds$trt)))
    
    gc13 = ggplot(ds, aes(x = NMDS1, y = NMDS3, colour = ds$trt)) +
      geom_segment(data = segs,
                   mapping = aes(xend = oNMDS1, yend = oNMDS3)) +
      geom_point(data = cent, 
                 size = 3, 
                 aes(colour = trt,
                     shape = time)) +
      geom_point(size = 1) +
      coord_fixed()     + 
      scale_color_manual(name = "Condition", values = my.ggplot.palette) +
      ggtitle('Centroids') + 
      scale_shape_manual(name = "Hours",
                         breaks = levels(time.levels) ,
                         values =  c(1, 16) #, 0, 15, 2, 17, 8)
                         ) +
      theme(axis.text.y = element_text(colour = "black", size = 10, face = "bold"),
            axis.text.x = element_text(colour = "black", face = "bold", size = 10),
            legend.text = element_text(size = 6, 
                                       #face ="bold", 
                                       colour ="black"
            ),
            legend.position = "none", axis.title.y = element_text(face = "bold", size = 14),
            axis.title.x = element_text(face = "bold", size = 14, colour = "black"),
            legend.title = element_text(size = 8, 
                                        colour = "black"#, 
                                        #face = "bold"
            ),
            panel.background = element_blank(), panel.border = element_rect(colour = "black", 
                                                                            fill = NA, 
                                                                            size = 1.2),
            legend.key=element_blank())
    
    ds = data.scores
    ds$trt = ds$Treatment # paste(ds$Treatment, ds$SamplingDay, sep = '_')
    cent <- aggregate(cbind(NMDS2, NMDS3) ~ trt, data = ds, FUN = mean)
    cent$time = factor(as.numeric(gsub('h', '', gsub('.*_', '', cent$trt))), levels = levels(time.levels))
    cent$stress = factor(gsub('_.*', '', cent$trt), levels = unique(gsub('_.*', '', cent$trt)))
    segs <- merge(ds, setNames(cent, c('trt','oNMDS2','oNMDS3')),
                  by = 'trt', sort = FALSE)
    ds$time = factor(as.numeric(gsub('h', '', gsub('.*_', '', ds$trt))), levels = levels(time.levels))
    ds$stress = factor(gsub('_.*', '', ds$trt), levels = unique(gsub('_.*', '', ds$trt)))
    
    gc23 = ggplot(ds, aes(x = NMDS2, y = NMDS3, colour = ds$trt)) +
      geom_segment(data = segs,
                   mapping = aes(xend = oNMDS2, yend = oNMDS3)) +
      geom_point(data = cent, 
                 size = 3, 
                 aes(colour = trt,
                     shape = time)) +
      geom_point(size = 1) +
      coord_fixed()     + 
      scale_color_manual(name = "Condition", values = my.ggplot.palette) +
      ggtitle('Centroids') + 
      scale_shape_manual(name = "Hours",
                         breaks = levels(time.levels) ,
                         values =  c(1, 16) #, 0, 15, 2, 17, 8)
                         ) +
      theme(axis.text.y = element_text(colour = "black", size = 10, face = "bold"),
            axis.text.x = element_text(colour = "black", face = "bold", size = 10),
            legend.text = element_text(size = 6, 
                                       #face ="bold", 
                                       colour ="black"
            ),
            legend.position = "right", axis.title.y = element_text(face = "bold", size = 14),
            axis.title.x = element_text(face = "bold", size = 14, colour = "black"),
            legend.title = element_text(size = 8, 
                                        colour = "black"#, 
                                        #face = "bold"
            ),
            panel.background = element_blank(), panel.border = element_rect(colour = "black", 
                                                                            fill = NA, 
                                                                            size = 1.2),
            legend.key=element_blank())
    
    
    return(list(g12, g13, g23, gc12, gc13, gc23))

    }

```

## fixed Venn

```{r, echo=FALSE, message=FALSE, warning=FALSE}

# fixin f-ction

my.vennDiagram <- function (object, include = "both", names = NULL, mar = rep(1,
    4), cex = c(1.5, 1, 0.7), lwd = 1, circle.col = NULL, counts.col = NULL,
    show.include = NULL, ...)
{
    include <- as.character(include)
    LenInc <- min(length(include), 2)
    if (is(object, "VennCounts")) {
        include <- include[1]
        LenInc <- 1
    }
    else {
        if (LenInc > 1)
            z2 <- limma::vennCounts(object, include = include[2])[,
                "Counts"]
        object <- limma::vennCounts(object, include = include[1])
    }
    z <- object[, "Counts"]
    nsets <- ncol(object) - 1
    if (nsets > 5)
        stop("Can't plot Venn diagram for more than 5 sets")
    VennZone <- object[, 1:nsets, drop = FALSE]
    VennZone <- apply(VennZone, 1, function(x) paste(x, sep = "",
        collapse = ""))
    names(z) <- VennZone
    if (length(include) == 2)
        names(z2) <- VennZone
    if (is.null(names))
        names <- colnames(object)[1:nsets]
    FILL.COL <- TRUE
    if (is.null(circle.col)) {
        circle.col <- par("col")
        FILL.COL <- FALSE
    }
    if (length(circle.col) < nsets)
        circle.col <- rep(circle.col, length.out = nsets)
    if (is.null(counts.col))
        counts.col <- par("col")
    if (length(counts.col) < LenInc)
        counts.col <- rep(counts.col, length.out = LenInc)
    if (is.null(show.include))
        show.include <- as.logical(LenInc - 1)
    old.par <- par()$mar
    on.exit(par(mar = old.par))
    par(mar = mar)
    if (nsets <= 3) {
        plot(x = 0, y = 0, type = "n", xlim = c(-4, 4), ylim = c(-4,
            4), xlab = "", ylab = "", axes = FALSE, ...)
        theta <- 2 * pi * (0:360)/360
        xcentres <- switch(nsets, 0, c(-1, 1), c(-1, 1, 0))
        ycentres <- switch(nsets, 0, c(0, 0), c(1, 1, -2)/sqrt(3))
        r <- 1.5
        xtext <- switch(nsets, -1.2, c(-1.2, 1.2), c(-1.2, 1.2,
            0))
        ytext <- switch(nsets, 1.8, c(1.8, 1.8), c(2.4, 2.4,
            -3))
        for (circle in 1:nsets) {
            if (!FILL.COL)
                lines(xcentres[circle] + r * cos(theta), ycentres[circle] +
                  r * sin(theta), lwd = lwd, col = circle.col[circle])
            if (FILL.COL) {
                RGB <- col2rgb(circle.col[circle])/255
                ALPHA <- 0.06
                RGB.ALP <- rgb(RGB[1, 1], RGB[2, 1], RGB[3, 1],
                  alpha = ALPHA)
                polygon(xcentres[circle] + r * cos(theta), ycentres[circle] +
                  r * sin(theta), border = circle.col[circle],
                  lwd = lwd, col = RGB.ALP)
            }
            text(xtext[circle], ytext[circle], names[circle],
                cex = cex)
        }
        switch(nsets, rect(-3, -2.5, 3, 2.5), rect(-3, -2.5,
            3, 2.5), rect(-3, -3.5, 3, 3.3))
        showCounts <- switch(nsets, function(counts, cex, adj,
            col, leg) {
             text(2.3, -2.1, sprintf("Not in any =  %i", counts[1]), cex = cex, col = col,
                 adj = adj)
            text(0, 0, counts[2], cex = cex, col = col, adj = adj)
            if (show.include) text(-2.3, -2.1, leg, cex = cex,
                col = col, adj = adj)
        }, function(counts, cex, adj, col, leg) {
             text(2.3, -2.1, sprintf("Not in any = %i", counts[1]), cex = cex, col = col,
                 adj = adj)
            text(1.5, 0.1, counts[2], cex = cex, col = col, adj = adj)
            text(-1.5, 0.1, counts[3], cex = cex, col = col,
                adj = adj)
            text(0, 0.1, counts[4], cex = cex, col = col, adj = adj)
            if (show.include) text(-2.3, -2.1, leg, cex = cex,
                col = col, adj = adj)
        }, function(counts, cex, adj, col, leg) {
             text(2.5, -3, sprintf("Not in any = %i", counts[1]), cex = cex, col = col, adj = adj)
            text(0, -1.7, counts[2], cex = cex, col = col, adj = adj)
            text(1.5, 1, counts[3], cex = cex, col = col, adj = adj)
            text(0.75, -0.35, counts[4], cex = cex, col = col,
                adj = adj)
            text(-1.5, 1, counts[5], cex = cex, col = col, adj = adj)
            text(-0.75, -0.35, counts[6], cex = cex, col = col,
                adj = adj)
            text(0, 0.9, counts[7], cex = cex, col = col, adj = adj)
            text(0, 0, counts[8], cex = cex, col = col, adj = adj)
            if (show.include) text(-2.5, -3, leg, cex = cex,
                col = col, adj = adj)
        })
        if (LenInc == 1)
            adj <- c(0.5, 0.5)
        else adj <- c(0.5, 0)
        print(z)
        showCounts(counts = z, cex = cex[1], adj = adj, col = counts.col[1],
            leg = include[1])
        if (LenInc == 2)
            showCounts(counts = z2, cex = cex[1], adj = c(0.5,
                1), col = counts.col[2], leg = include[2])
        return(invisible())
    }
    plot(c(-20, 420), c(-20, 420), type = "n", axes = FALSE,
        ylab = "", xlab = "", ...)
    relocate_elp <- function(e, alpha, x, y) {
        phi <- (alpha/180) * pi
        xr <- e[, 1] * cos(phi) + e[, 2] * sin(phi)
        yr <- -e[, 1] * sin(phi) + e[, 2] * cos(phi)
        xr <- x + xr
        yr <- y + yr
        cbind(xr, yr)
    }
    if (4 == nsets) {
        rect(-20, -20, 420, 400)
        elps <- cbind(162 * cos(seq(0, 2 * pi, len = 1000)),
            108 * sin(seq(0, 2 * pi, len = 1000)))
        if (!FILL.COL) {
            polygon(relocate_elp(elps, 45, 130, 170), border = circle.col[1],
                lwd = lwd)
            polygon(relocate_elp(elps, 45, 200, 200), border = circle.col[2],
                lwd = lwd)
            polygon(relocate_elp(elps, 135, 200, 200), border = circle.col[3],
                lwd = lwd)
            polygon(relocate_elp(elps, 135, 270, 170), border = circle.col[4],
                lwd = lwd)
        }
        if (FILL.COL) {
            RGB <- col2rgb(circle.col)/255
            ALPHA <- 0.06
            RGB.ALP1 <- rgb(RGB[1, 1], RGB[2, 1], RGB[3, 1],
                alpha = ALPHA)
            RGB.ALP2 <- rgb(RGB[1, 2], RGB[2, 2], RGB[3, 2],
                alpha = ALPHA)
            RGB.ALP3 <- rgb(RGB[1, 3], RGB[2, 3], RGB[3, 3],
                alpha = ALPHA)
            RGB.ALP4 <- rgb(RGB[1, 4], RGB[2, 4], RGB[3, 4],
                alpha = ALPHA)
            polygon(relocate_elp(elps, 45, 130, 170), border = circle.col[1],
                lwd = lwd, col = RGB.ALP1)
            polygon(relocate_elp(elps, 45, 200, 200), border = circle.col[2],
                lwd = lwd, col = RGB.ALP2)
            polygon(relocate_elp(elps, 135, 200, 200), border = circle.col[3],
                lwd = lwd, col = RGB.ALP3)
            polygon(relocate_elp(elps, 135, 270, 170), border = circle.col[4],
                lwd = lwd, col = RGB.ALP4)
        }
        text(35, 315, names[1], cex = cex[1])
        text(138, 350, names[2], cex = cex[1])
        text(262, 347, names[3], cex = cex[1])
        text(365, 315, names[4], cex = cex[1])
        text(35, 250, z["1000"], cex = cex[2], col = counts.col[1],
            )
        text(140, 315, z["0100"], cex = cex[2], col = counts.col[1])
        text(260, 315, z["0010"], cex = cex[2], col = counts.col[1])
        text(365, 250, z["0001"], cex = cex[2], col = counts.col[1])
        text(90, 282, z["1100"], cex = cex[3], col = counts.col[1])
        text(95, 110, z["1010"], cex = cex[2], col = counts.col[1])
        text(200, 52, z["1001"], cex = cex[3], col = counts.col[1])
        text(200, 292, z["0110"], cex = cex[2], col = counts.col[1])
        text(300, 110, z["0101"], cex = cex[2], col = counts.col[1])
        text(310, 282, z["0011"], cex = cex[3], col = counts.col[1])
        text(130, 230, z["1110"], cex = cex[2], col = counts.col[1])
        text(245, 81, z["1101"], cex = cex[3], col = counts.col[1])
        text(155, 81, z["1011"], cex = cex[3], col = counts.col[1])
        text(270, 230, z["0111"], cex = cex[2], col = counts.col[1])
        text(200, 152, z["1111"], cex = cex[2], col = counts.col[1])
         text(400, 15, sprintf("Not in any = %i", z["0000"]), cex = cex[1], col = counts.col[1])
        if (length(include) == 2) {
            text(35, 238, z2["1000"], cex = cex[2], col = counts.col[2])
            text(140, 304, z2["0100"], cex = cex[2], col = counts.col[2])
            text(260, 304, z2["0010"], cex = cex[2], col = counts.col[2])
            text(365, 238, z2["0001"], cex = cex[2], col = counts.col[2])
            text(90, 274, z2["1100"], cex = cex[3], col = counts.col[2])
            text(95, 100, z2["1010"], cex = cex[2], col = counts.col[2])
            text(200, 43, z2["1001"], cex = cex[3], col = counts.col[2])
            text(200, 280, z2["0110"], cex = cex[2], col = counts.col[2])
            text(300, 100, z2["0101"], cex = cex[2], col = counts.col[2])
            text(310, 274, z2["0011"], cex = cex[3], col = counts.col[2])
            text(130, 219, z2["1110"], cex = cex[2], col = counts.col[2])
            text(245, 71, z2["1101"], cex = cex[3], col = counts.col[2])
            text(155, 72, z2["1011"], cex = cex[3], col = counts.col[2])
            text(270, 219, z2["0111"], cex = cex[2], col = counts.col[2])
            text(200, 140, z2["1111"], cex = cex[2], col = counts.col[2])
             text(400, -2, sprintf("Not in any = %i", z2["0000"]), cex = cex[1], col = counts.col[2])
            if (show.include) {
                text(10, 15, include[1], cex = cex[1], col = counts.col[1])
                text(10, -2, include[2], cex = cex[1], col = counts.col[2])
            }
        }
        return(invisible())
    }
    rect(-20, -30, 430, 430)
    elps <- cbind(150 * cos(seq(0, 2 * pi, len = 1000)), 60 *
        sin(seq(0, 2 * pi, len = 1000)))
    if (!FILL.COL) {
        polygon(relocate_elp(elps, 90, 200, 250), border = circle.col[1],
            lwd = lwd)
        polygon(relocate_elp(elps, 162, 250, 220), border = circle.col[2],
            lwd = lwd)
        polygon(relocate_elp(elps, 234, 250, 150), border = circle.col[3],
            lwd = lwd)
        polygon(relocate_elp(elps, 306, 180, 125), border = circle.col[4],
            lwd = lwd)
        polygon(relocate_elp(elps, 378, 145, 200), border = circle.col[5],
            lwd = lwd)
    }
    if (FILL.COL) {
        RGB <- col2rgb(circle.col)/255
        ALPHA <- 0.06
        RGB.ALP1 <- rgb(RGB[1, 1], RGB[2, 1], RGB[3, 1], alpha = ALPHA)
        RGB.ALP2 <- rgb(RGB[1, 2], RGB[2, 2], RGB[3, 2], alpha = ALPHA)
        RGB.ALP3 <- rgb(RGB[1, 3], RGB[2, 3], RGB[3, 3], alpha = ALPHA)
        RGB.ALP4 <- rgb(RGB[1, 4], RGB[2, 4], RGB[3, 4], alpha = ALPHA)
        RGB.ALP5 <- rgb(RGB[1, 5], RGB[2, 5], RGB[3, 5], alpha = ALPHA)
        polygon(relocate_elp(elps, 90, 200, 250), border = circle.col[1],
            lwd = lwd, col = RGB.ALP1)
        polygon(relocate_elp(elps, 162, 250, 220), border = circle.col[2],
            lwd = lwd, col = RGB.ALP2)
        polygon(relocate_elp(elps, 234, 250, 150), border = circle.col[3],
            lwd = lwd, col = RGB.ALP3)
        polygon(relocate_elp(elps, 306, 180, 125), border = circle.col[4],
            lwd = lwd, col = RGB.ALP4)
        polygon(relocate_elp(elps, 378, 145, 200), border = circle.col[5],
            lwd = lwd, col = RGB.ALP5)
    }
    text(50, 285, names[1], cex = cex[1])
    text(200, 415, names[2], cex = cex[1])
    text(350, 305, names[3], cex = cex[1])
    text(350, 20, names[4], cex = cex[1])
    text(100, -10, names[5], cex = cex[1])
    text(61, 231, z["10000"], cex = cex[2], col = counts.col[1])
    text(200, 332, z["01000"], cex = cex[2], col = counts.col[1])
    text(321, 248, z["00100"], cex = cex[2], col = counts.col[1])
    text(290, 84, z["00010"], cex = cex[2], col = counts.col[1])
    text(132, 72, z["00001"], cex = cex[2], col = counts.col[1])
    text(146, 253, z["11000"], cex = cex[3], col = counts.col[1])
    text(123, 191, z["10100"], cex = cex[3], col = counts.col[1])
    text(275, 155, z["10010"], cex = cex[3], col = counts.col[1])
    text(137, 149, z["10001"], cex = cex[3], col = counts.col[1])
    text(243, 271, z["01100"], cex = cex[3], col = counts.col[1])
    text(175, 270, z["01010"], cex = cex[3], col = counts.col[1])
    text(187, 120, z["01001"], cex = cex[3], col = counts.col[1])
    text(286, 193, z["00110"], cex = cex[3], col = counts.col[1])
    text(267, 238, z["00101"], cex = cex[3], col = counts.col[1])
    text(228, 108, z["00011"], cex = cex[3], col = counts.col[1])
    text(148, 213, z["11100"], cex = cex[3], col = counts.col[1])
    text(159, 255, z["11010"], cex = cex[3], col = counts.col[1])
    text(171, 144, z["11001"], cex = cex[3], col = counts.col[1])
    text(281, 178, z["10110"], cex = cex[3], col = counts.col[1])
    text(143, 166, z["10101"], cex = cex[3], col = counts.col[1])
    text(252, 148, z["10011"], cex = cex[3], col = counts.col[1])
    text(205, 258, z["01110"], cex = cex[3], col = counts.col[1])
    text(254, 248, z["01101"], cex = cex[3], col = counts.col[1])
    text(211, 121, z["01011"], cex = cex[3], col = counts.col[1])
    text(267, 214, z["00111"], cex = cex[3], col = counts.col[1])
    text(170, 234, z["11110"], cex = cex[3], col = counts.col[1])
    text(158, 172, z["11101"], cex = cex[3], col = counts.col[1])
    text(212, 142, z["11011"], cex = cex[3], col = counts.col[1])
    text(263, 183, z["10111"], cex = cex[3], col = counts.col[1])
    text(239, 235, z["01111"], cex = cex[3], col = counts.col[1])
    text(204, 193, z["11111"], cex = cex[2], col = counts.col[1])
     text(400, 7, sprintf("Not in any = %i", z["00000"]), cex = cex[1], col = counts.col[1])
    if (length(include) == 2) {
        text(61, 220, z2["10000"], cex = cex[2], col = counts.col[2])
        text(200, 321, z2["01000"], cex = cex[2], col = counts.col[2])
        text(321, 237, z2["00100"], cex = cex[2], col = counts.col[2])
        text(290, 73, z2["00010"], cex = cex[2], col = counts.col[2])
        text(132, 61, z2["00001"], cex = cex[2], col = counts.col[2])
        text(146, 244, z2["11000"], cex = cex[3], col = counts.col[2])
        text(123, 180, z2["10100"], cex = cex[3], col = counts.col[2])
        text(275, 144, z2["10010"], cex = cex[3], col = counts.col[2])
        text(137, 143, z2["10001"], cex = cex[3], col = counts.col[2])
        text(243, 260, z2["01100"], cex = cex[3], col = counts.col[2])
        text(175, 259, z2["01010"], cex = cex[3], col = counts.col[2])
        text(187, 110, z2["01001"], cex = cex[3], col = counts.col[2])
        text(286, 186, z2["00110"], cex = cex[3], col = counts.col[2])
        text(267, 230, z2["00101"], cex = cex[3], col = counts.col[2])
        text(228, 97, z2["00011"], cex = cex[3], col = counts.col[2])
        text(148, 203, z2["11100"], cex = cex[3], col = counts.col[2])
        text(159, 249, z2["11010"], cex = cex[3], col = counts.col[2])
        text(171, 137, z2["11001"], cex = cex[3], col = counts.col[2])
        text(281, 171, z2["10110"], cex = cex[3], col = counts.col[2])
        text(143, 155, z2["10101"], cex = cex[3], col = counts.col[2])
        text(252, 137, z2["10011"], cex = cex[3], col = counts.col[2])
        text(205, 247, z2["01110"], cex = cex[3], col = counts.col[2])
        text(254, 242, z2["01101"], cex = cex[3], col = counts.col[2])
        text(211, 112, z2["01011"], cex = cex[3], col = counts.col[2])
        text(267, 207, z2["00111"], cex = cex[3], col = counts.col[2])
        text(170, 223, z2["11110"], cex = cex[3], col = counts.col[2])
        text(158, 162, z2["11101"], cex = cex[3], col = counts.col[2])
        text(212, 133, z2["11011"], cex = cex[3], col = counts.col[2])
        text(263, 172, z2["10111"], cex = cex[3], col = counts.col[2])
        text(239, 228, z2["01111"], cex = cex[3], col = counts.col[2])
        text(204, 182, z2["11111"], cex = cex[2], col = counts.col[2])
         text(400, -10, sprintf("Not in any = %i", z2["00000"]), cex = cex[1], col = counts.col[2])
        if (show.include) {
            text(10, 7, include[1], cex = cex[1], col = counts.col[1])
            text(10, -10, include[2], cex = cex[1], col = counts.col[2])
        }
    }
    invisible()
}


```



# Input data

```{r}

fp = file.path('..', 'input')
fn = 'raw_counts.txt'

counts = data.table::fread(file = file.path(fp, fn))

fn = 'analytes.txt'
pheno = data.table::fread(file = file.path(fp, fn))

```


## Define sample groups for later comparisons

```{r}


group = factor(pheno$Group, levels = c( "control_24h",
                                        "control_48h",
                                        "mycorrhized_24h",
                                        "mycorrhized_48h",
                                        "infected_24h",
                                        "infected_48h",
                                        "myco_infected_24h",
                                        "myco_infected_48h"))
# group 
(n = length(levels(group)))



```

### Palletes

<https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html#the-color-scales>

<https://renenyffenegger.ch/notes/development/languages/R/packages/RColorBrewer/index>

```{r}



palette = brewer.pal(n,'Paired')[c(3,4, 7,8, 1,2, 5,6)]

grid = raster(ncols=n, nrows = 1, xmn=1, xmx=n, ymn=1, ymx=2)

values(grid) = 1:n

par(mar=rep(0.5, 4))
plot(grid, 
     col=palette, 
     legend=FALSE, 
     axes = 0, 
     box=FALSE)
text(grid, labels = levels(group), srt = 90)

```



## Raw reads

### Specify library sizes for each sample


```{r}

rownames(counts) = counts$GeneID
reads.raw = edgeR::DGEList(counts=counts, group=group)


```



### Filter low expressed reads

```{r}

keep.exprs = edgeR::filterByExpr(reads.raw, group = group, min.count = 50, min.total.count = 150)
table(keep.exprs)
reads.norm = reads.raw[keep.exprs, keep.lib.sizes=TRUE]


```


### Normalise


```{r}

reads.norm = edgeR::calcNormFactors(reads.norm, method = 'TMM')
reads.norm$samples ## check if it makes sense per your experiment



```




### Plot filtered raw and normalised counts

#### 'spiderplots' raw

```{r}

mymat = counts[, -1]
all(colnames(mymat) == pheno$SampleName)
dim(mymat)
stress.levels = group
time.levels = factor(pheno$time, levels = c('24', '48'))
title = 'raw unfiltered'
PlantNo = as.factor(pheno$replicate)
NMDS.palette = palette


NMDS.plots = my.NMDS(mymat = mymat, 
                     stress.levels = stress.levels, 
                     time.levels = time.levels, 
                     title = title,
                     my.ggplot.palette = palette)

cowplot::plot_grid(NMDS.plots[[1]], NMDS.plots[[2]], NMDS.plots[[3]],  
                   NMDS.plots[[4]], NMDS.plots[[5]], NMDS.plots[[6]],
                   ncol=3, nrow = 2)



```


#### 'spiderplots' normalised and filtered

```{r}




mymat = edgeR::cpm(reads.norm, 
            normalized.lib.sizes = TRUE,
            log = FALSE, prior.count = 2)
all(colnames(mymat) == pheno$SampleName)
dim(mymat)
stress.levels = group
time.levels = factor(pheno$time, levels = c('24', '48'))
title = 'filtered normalised'
PlantNo = as.factor(pheno$replicate)
NMDS.palette = palette


NMDS.plots = my.NMDS(mymat = mymat, 
                     stress.levels = stress.levels, 
                     time.levels = time.levels, 
                     title = title,
                     my.ggplot.palette = palette)

cowplot::plot_grid(NMDS.plots[[1]], NMDS.plots[[2]], NMDS.plots[[3]],  
                   NMDS.plots[[4]], NMDS.plots[[5]], NMDS.plots[[6]],
                   ncol=3, nrow = 2)






```

#### Principal Coordinate Analysis

```{r}


d = dist(t(mymat), method = "euclidean", diag = TRUE, upper = TRUE)
dim(d)
mds = ape::pcoa(d)

all(pheno$SampleName == labels(d))
l = gsub('_1|_2|_3', '', labels(d))

# plot
plot(mds$vectors[,1], mds$vectors[,2], type = "p", xlab = "", ylab = "",
     axes = FALSE, main = "PCoA", col = palette[as.numeric(group)], pch = 19, cex = 2.5)
text(mds$vectors[,1], mds$vectors[,2], l, 
     cex = 0.75, xpd = TRUE)



```


#### Heatmaps

<https://jokergoo.github.io/ComplexHeatmap-reference/book/>

<https://r-charts.com/color-palettes/>

```{r}

d = as.matrix(d)

# col_fun = colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))
# col_fun(seq(-3, 3))


ComplexHeatmap::Heatmap(d, 
                        column_title = "Euclidean distance", 
                        col = paletteer::paletteer_c("ggthemes::Blue-Green Sequential", 30),
                        rect_gp = grid::gpar(col = "white", lwd = 2),
                        row_dend_width = unit(20, "mm"),
                        column_dend_height = unit(20, "mm"))



cr = cor(mymat, 
         use = "pairwise.complete.obs",
         method = 'pearson') #"kendall")

col_fun = circlize::colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))

range(cr)

ComplexHeatmap::Heatmap(cr, 
                        column_title = 'PCC', # "kendall cor", 
                        rect_gp = grid::gpar(col = "white", lwd = 2),
                        col = col_fun,
                        row_dend_width = unit(40, "mm"),
                        column_dend_height = unit(40, "mm"))

```


#### Density plot

```{r}

par(mfrow = c(1,3))
op = par(mar = c(8,7,4,2) + 0.1)
boxplot(log(counts[, -1] + 0.5, 2), 
        xlab="", 
        ylab="Log2 (Unfiltered counts)",
        las=2,
        col=rep(palette, each = 3),
        cex = 1.5, cex.axis = 1.0, cex.lab=1.5)
boxplot(log(reads.norm$counts + 0.5, 2), 
        xlab="", 
        ylab="Log2 (Filtered counts)",
        las=2,
        col=rep(palette, each = 3),
        cex = 1.5, cex.axis = 1.0, cex.lab=1.5)
boxplot(log(edgeR::cpm(reads.norm, 
            normalized.lib.sizes = TRUE,
            log = FALSE, prior.count = 2) + 0.5, 2),
        xlab="", 
        ylab="Log2 (Normalised filtered counts)",
        las=2,
        col=rep(palette, each = 3),
        cex = 1.5, cex.axis = 1.0, cex.lab=1.5)

par(op)
par(mfrow = c(1,1))

```

# limma-voom protocol

## Create design matrix

```{r}

design = model.matrix(~0+group)
colnames(design)
colnames(design) = levels(group)
rownames(design) = pheno$SampleName
# design

```


## voom

```{r}


v = limma::voom(counts = reads.norm, design = design, plot = TRUE)



```


## Fit linear model for each gene given a series of arrays

```{r}

fit = limma::lmFit(v, design)

```

## Construct Matrix of Custom Contrasts

```{r}


fn = 'comparisons.xlsx'
comparisons = openxlsx::read.xlsx(xlsxFile = file.path(fp, fn),
                                  sheet = 1,
                                  startRow = 1,
                                  colNames = FALSE,
                                  rowNames = FALSE,
                                  detectDates = FALSE,
                                  skipEmptyRows = TRUE,
                                  skipEmptyCols = TRUE,
                                  rows = NULL,
                                  cols = NULL,
                                  check.names = FALSE,
                                  sep.names = ".",
                                  namedRegion = NULL,
                                  na.strings = "NA",
                                  fillMergedCells = FALSE
                                  )
# vector
s = paste0(comparisons[, 1], '-', comparisons[, 2])


```



```{r}


contrastMatrix = limma::makeContrasts(contrasts = s,
                                      levels=design)


```

## Compute Contrasts from Linear Model Fit

```{r}


fit2 = limma::contrasts.fit(fit, contrastMatrix)


```

## Empirical Bayes Statistics for Differential Expression

```{r}


fit2 = limma::eBayes(fit2)


```


# Collect (merge) results

```{r}

cnt = 1
res = NULL
by = 'GeneID'
fpo = file.path('..', 'output', 'limma-out')
dir.create(fpo)

for (i in colnames(fit2$coefficients) ) {
  
  # sprintf("%03.0f", cnt)
  print(i)
  print('DE')

  topTn = limma::topTable(fit2, coef = i, number=Inf, sort.by="none")
  
  print(table(topTn$adj.P.Val < 0.05))
  
  fn = paste0(sprintf("%03.0f", cnt), '_', i, '.txt')
  
  data.table::fwrite(topTn, file.path(fpo, fn), sep = '\t')
  
  
  colnames(topTn)[2:ncol(topTn)] = paste(colnames(topTn)[2:ncol(topTn)], i, sep = ' | ')
  
  if (cnt == 1) {
    res = topTn
  } else {
    res = merge(res, topTn, by = by, all.x =  TRUE, all.y = TRUE)
  }

  cnt = cnt + 1

}

fpo = file.path('..', 'output')
fn = 'limmaResults.xlsx'

ind = grep('GeneID|logFC|P.Val', colnames(res))

openxlsx::write.xlsx(res[, ind], file = file.path(fpo, fn), asTable = TRUE, overwrite = TRUE)

ind = grep('GeneID|logFC|adj.P.Val', colnames(res))

merge = merge(res[, ind], counts, by = by, all.x = TRUE, all.y = FALSE)

fn = 'filtered-and-counts.xlsx'
openxlsx::write.xlsx(merge, file = file.path(fpo, fn), asTable = TRUE, overwrite = TRUE)


```

# Venn

## limma


Read what to plot from a file ```VennCombo.txt```

```{r}

r = limma::decideTests(fit2,
                       adjust.method = "BH",
                       p.value = 0.05,
                       lfc = 0) # no log2FC cut-off
colnames(r)
# ggVennDiagram::ggVennDiagram(as.list(r[, 1:7]),
#                              label = "none", edge_size = 2) +
#   scale_fill_distiller(palette = "RdBu")

fn = 'VennCombo.txt'
VennCombo = as.data.frame(data.table::fread(file = file.path(fp, fn), header = FALSE))

for (i in 1:ncol(VennCombo)) {
  
  # print(i)
  # paste0(VennCombo[, i], collapse = '|')
  ind = setdiff(match(VennCombo[, i], colnames(r)), NA)
  # print(ind)
  subset = r[, ind]
  my.vennDiagram(subset,
    include=c("up", "down"),
    counts.col=c("red", "blue"),
    circle.col = brewer.pal(length(ind),'Dark2'),
    cex = 0.66,
    show.include = TRUE,
    lwd = 1.5)
  
}




```



## Venn without ```decideTests``` from merged file

```{r}


ind1 = grep('GeneID', colnames(merge))
ind2 = grep('adj.P', colnames(merge))
ind3 = grep('logFC', colnames(merge))
ind = sort(c(ind2, ind3))

forVenn = merge[, ind]
rownames(forVenn) = merge[, ind1]

ind2 = grep('adj.P', colnames(forVenn))
ind3 = grep('logFC', colnames(forVenn))
for (i in 1:length(ind2)) {
  # cat(colnames(forVenn)[ind2[i]], colnames(forVenn)[ind3[i]], '\n')
  myColFDR = forVenn[,ind2[i]]
  unsig = which(myColFDR >= 0.05)
  forVenn[unsig,ind3[i]] = 0
  sig = which(myColFDR < 0.05)
  # any(duplicated(sort(c(sig, unsig))))
  forVenn[sig[forVenn[sig,ind3[i]] < 0], ind3[i]] = -1
  forVenn[sig[forVenn[sig,ind3[i]] > 0], ind3[i]] = 1
  # table(forVenn[ind3[i]])
}

toPlot = forVenn[, ind3]


for (i in 1:ncol(VennCombo)) {
  
  # print(i)
  # paste0(VennCombo[, i], collapse = '|')
  ind = setdiff(match(VennCombo[, i], gsub('logFC \\| ', '', colnames(toPlot))), NA)
  # print(ind)
  subset = toPlot[, ind]
  colnames(subset) = gsub('logFC \\| ', '', colnames(subset))
  my.vennDiagram(subset,
    include=c("up", "down"),
    counts.col=c("red", "blue"),
    circle.col = brewer.pal(length(ind),'Dark2'),
    cex = 0.66,
    show.include = TRUE,
    lwd = 1.5)
  
}



```


## VennDiagram::venn.diagram

```{r}

mylist = list()
for(i in 1:ncol(toPlot)){
    mylist[[i]] = rownames(toPlot)[!is.na(toPlot[,i])]
  }
length(mylist)
names(mylist) = gsub('logFC \\| ', '', colnames(toPlot))

for (i in 1:ncol(VennCombo)) {
  
  # print(i)
  # paste0(VennCombo[, i], collapse = '|')
  ind = setdiff(match(VennCombo[, i], gsub('logFC \\| ', '', names(mylist))), NA)
  # print(ind)
  subset = mylist[ind]
  
  VennDiagram::venn.diagram(
      x = (as.list(subset)),
      category.names = names(subset),
      filename = file.path(".." , 'output', paste0(i, '_Venn.png')),
      output=TRUE,
      
      main = paste0('\n', '\nVenn', i),
      main.cex = 0.5,
      main.pos  = c(0.5, 1.20),
      sub.cex = 1.25,
      
      
      # Output features
      imagetype="png" ,
      height = 600 , 
      width = 600 , 
      resolution = 300,
      compression = "lzw",
      
      # Circles
      lwd = 2,
      lty = 'blank',
      fill = brewer.pal(length(names(subset)), "Set1"),
      
      # Numbers
      cex = .2,
      fontface = "bold",
      fontfamily = "sans",
      
      # Set names
      cat.cex = 0.2,
      cat.fontface = "bold",
      cat.default.pos = "outer",
      # cat.pos = c(-27, 27, 135),
      # cat.dist = c(0.055, 0.055, 0.085),
      margin = 0.2,
      cat.fontfamily = "sans"#,
      #rotation = 1
  )
}


```


# For GSEA

```{r}

fn = 'norm.txt'
norm = edgeR::cpm(reads.norm, 
                  normalized.lib.sizes = TRUE,
                  log = FALSE, prior.count = 2)
norm = cbind(reads.norm$genes, norm)
colnames(norm)[1] = 'GeneID'


data.table::fwrite(norm, 
                   file.path(fpo, fn), sep = '\t',
                   row.names = FALSE)


```


# Session Info

```{r}

sessionInfo()


```

