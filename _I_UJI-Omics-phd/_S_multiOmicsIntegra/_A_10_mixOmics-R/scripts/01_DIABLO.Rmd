---
title: "01_DIABLO"
author: "Maria, zagor"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}


library(mixOmics)
set.seed(123456) 

# if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")

# BiocManager::install("BiocParallel")
library(BiocParallel)


```

# Data

```{r}

fp = file.path('..', 'input')


fn = 'Enzymomics_only_24.txt'
E = read.delim(file = file.path(fp, fn), 
               header = TRUE, 
               sep = "\t", 
               quote = NULL,
               dec = ".", 
               fill = TRUE, 
               comment.char = '@')

fn = 'Metabolomics_only_24.txt'
M = read.delim(file = file.path(fp, fn), 
               header = TRUE, 
               sep = "\t", 
               quote = NULL,
               dec = ".", 
               fill = TRUE, 
               comment.char = '@')

fn = 'phosphoProteomics_filtered_sig_24.txt'
P = read.delim(file = file.path(fp, fn), 
               header = TRUE, 
               sep = "\t", 
               quote = NULL,
               dec = ".", 
               fill = TRUE, 
               comment.char = '@')

all(P$treatment == E$treatment)
all(P$treatment == M$treatment)


```


```{r}

data = list(Enz = as.matrix(E[, -1]),
            Met = as.matrix(M[, -1]),
            Pph = as.matrix(P[, -1]))



```

<https://mixomics.org/mixdiablo/diablo-tcga-case-study/>

```{r}


lapply(data, dim) # check their dimensions
Y = factor(E$treatment, levels = unique(E$treatment))
summary(Y)


```

# Pairwise PLS Comparisons

Circle Correlation Plots for pairwise PLS models 


Only displays the top 24 features for each dimension, subsetting by those with a correlation above 0.5

```{r}


list.keepX = c(24, 24) # select arbitrary values of features to keep
list.keepY = c(24, 24)

# generate three pairwise PLS models
pls1 <- spls(data[["Enz"]], data[["Met"]], 
             keepX = list.keepX, keepY = list.keepY) 
pls2 <- spls(data[["Enz"]], data[["Pph"]], 
             keepX = list.keepX, keepY = list.keepY)
pls3 <- spls(data[["Met"]], data[["Pph"]], 
             keepX = list.keepX, keepY = list.keepY)

# plot features of first PLS
plotVar(pls1, cutoff = 0.5, title = "(a) enzymomics vs metabolomics", 
        legend = c("enzymomics", "metabolomics"), 
        var.names = TRUE, style = 'graphics', 
        pch = c(16, 17), cex = c(0.5,0.5), 
        col = c('darkorchid', 'lightgreen'))
plotVar(pls1, cutoff = 0.5, title = "(a) enzymomics vs metabolomics", 
        legend = c("enzymomics", "metabolomics"), 
        var.names = FALSE, style = 'graphics', 
        pch = c(16, 17), cex = c(2,2), 
        col = c('darkorchid', 'lightgreen'))

# plot features of second PLS
plotVar(pls2, cutoff = 0.5, title = "(b) enzymomics vs phosphoproteomics", 
        legend = c("enzymomics", "phosphoproteomics"), 
        var.names = TRUE, style = 'graphics', 
        pch = c(16, 17), cex = c(0.5,0.5), 
        col = c('darkorchid', 'blue'))
plotVar(pls2, cutoff = 0.5, title = "(b) enzymomics vs phosphoproteomics", 
        legend = c("enzymomics", "phosphoproteomics"), 
        var.names = FALSE, style = 'graphics', 
        pch = c(16, 17), cex = c(2,2), 
        col = c('darkorchid', 'blue'))

# plot features of third PLS
plotVar(pls3, cutoff = 0.5, title = "(c) metabolomics vs phosphoproteomics", 
        legend = c("metabolomics", "phosphoproteomics"), 
        var.names = TRUE, style = 'graphics', 
        pch = c(16, 17), cex = c(0.5,0.5), 
        col = c('lightgreen', 'blue'))
plotVar(pls3, cutoff = 0.5, title = "(c) metabolomics vs phosphoproteomics", 
        legend = c("metabolomics", "phosphoproteomics"), 
        var.names = FALSE, style = 'graphics', 
        pch = c(16, 17), cex = c(2,2), 
        col = c('lightgreen', 'blue'))


```

## correlation

```{r}

cor(pls1$variates$X, pls1$variates$Y) # calculate correlation of Enz and Met
cor(pls2$variates$X, pls2$variates$Y) # calculate correlation of Enz and Pph
cor(pls3$variates$X, pls3$variates$Y) # calculate correlation of Met and Pph

```


# Design



```{r}

design = matrix(0.1, ncol = length(data), nrow = length(data), # for square matrix filled with 0.1s
                dimnames = list(names(data), names(data)))
diag(design) = 0 # set diagonal to 0s

design

```

#  the initial DIABLO 


```{r}

basic.diablo.model = block.splsda(X = data, Y = Y, ncomp = 5, design = design) # form basic DIABLO model

```


# Tuning the number of components

Choosing the number of components in block.plsda using perf() with 10 × 10-fold CV function 

```{r}
## ---- fig.cap = "FIGURE 2: Choosing the number of components in `block.plsda` using `perf()` with 10 × 10-fold CV function in the `breast.TCGA` study. Classification error rates (overall and balanced, see Section 7.3) are represented on the y-axis with respect to the number of components on the x-axis for each prediction distance presented in PLS-DA"----

perf.diablo = perf(basic.diablo.model, validation = 'Mfold', 
                   folds = 10, nrepeat = 10) # run component number tuning with repeated CV

plot(perf.diablo) # plot output of tuning

```


##  set the optimal ncomp value


```{r}


ncomp = perf.diablo$choice.ncomp$WeightedVote["Overall.BER", "centroids.dist"] # set the optimal ncomp value
perf.diablo$choice.ncomp$WeightedVote # show the optimal choice for ncomp for each dist metric
```

# Tuning the number of features

We choose the optimal number of variables to select in each data set using the tune.block.splsda() function, for a grid of keepX values for each type of omics. Note that the function has been set to favour a relatively small signature while allowing us to obtain a sufficient number of variables for downstream validation and/or interpretation.


## setup cluster - use SnowParam() on Widnows

<https://rdrr.io/bioc/BiocParallel/man/BiocParallelParam-class.html>


bplapply erro solution <https://support.bioconductor.org/p/133353/#133356>

```{r}

options(SnowParam=SnowParam(workers=4))
BPPARAM  = bpparam()




```


```{r}

# set grid of values for each component to test


 # test.keepX = list (Met = c(5:9, seq(10, 15, 2), seq(20,24,4)),
 #                    Enz = c(5:9, seq(10, 15, 2), seq(20,24,4)),
 #                    Pph = c(5:9, seq(10, 15, 2), seq(20,24,4)))

x <- list()
for (i in 1:length(data)){
x[[i]] <- c( seq(5,min(24, ncol(data[[i]])) ,2))
}
names(x) <- names(data)
test.keepX  <-  x
test.keepX


# You have provided a sequence of keepX of length: 10 for block Met and 10 for block Enz and 10 for block Pph.
# This results in 1000 models being fitted for each component and each nrepeat, this may take some time to run, be patient!
# Because of a too high number of 'folds' required, 2 folds were randomly assigned no data: the number of 'folds' is reduced to 8
 
 t1 = proc.time()
 
 # run the feature selection tuning
 
 tune.MIR = tune.block.splsda(X = data, Y = Y, ncomp = ncomp,
                               test.keepX = test.keepX, design = design,
                              validation = 'Mfold', folds = 8, nrepeat = 1,
                              BPPARAM  = BPPARAM , dist = "centroids.dist")
 t2 = proc.time()
 running_time = t2 - t1; running_time

list.keepX = tune.MIR$choice.keepX
list.keepX


fp = file.path('..', 'output')
fn = 'result-MIR-diablo_design0.1.RData'
save(tune.MIR,list.keepX, file = file.path(fp, fn))

```


The number of features to select on each component is returned in


```{r}



list.keepX = tune.MIR$choice.keepX # set the optimal values of features to retain
list.keepX


```

# Final model

```{r}


# set the optimised DIABLO model
final.diablo.model = block.splsda(X = data, Y = Y, ncomp = ncomp
                          , keepX = list.keepX
                          , design = design)

## Design matrix has changed to include Y; each block will be
##             linked to Y.



```



```{r}

# the features selected from components
for (comp in 1:ncomp){
cat("\nComponent ", comp,":\n")
for(i in 1:length(data)){
cat(names(data)[i],"\n")
print(selectVar(final.diablo.model, comp = comp)[[i]]$name)
}
}



```

